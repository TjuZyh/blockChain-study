**区块链技术与应用**

北大肖臻老师公开课

a

#### **Part One BitCoin**

##### **1.密码学原理**

​		比特币应用到了密码学中的两个功能：**1.哈希 2.签名**

**哈希函数：Crypotographic hash function** 

​	 —	**collision resistance** : 例如x≠y H(x)=H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。给出x，很难找到y，除非蛮力求解(brute-force)。
​			该性质的作用:对一个message求digest
​			比如message取m m的哈希值是H(m)=digest 如果有人想篡改m值而H(m)不变，则无法做到。
哈希碰撞无法人为制造，无法验证，是根据实践经验得来的。

​	—	**hiding ** ：哈希函数的计算过程是单向的，不可逆的。

​			(从H(x)无法推导出x) hiding性质前提是输入空间足够大，分布比较均匀。如果不是足够大，一般在x后面拼接一个随机数，如H(x||nonce)。
​			该性质的作用:和collision resistance 结合在一起，用来实现digital commitment(又称为digital equivalent of a sealed envelope)。把预测结果作为输入x，算出一个哈希值，将哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。

​	—	**puzzle friendly** 指哈希值的预算事先是不可预测的。假如哈希值是00...0XX...X，一样事先无法知道哪个值更容易算出这个结果，还是要一个一个带入。

​			比特币挖矿的过程中实际就是找一个nonce，nonce跟区块的块头里的其他信息合一起作为输入，得出的哈希值要小于等于某个指定的目标预值。H(block header)≤target。block header 指块头，块头里有很多域，其中一个域是我们可以设置的随机数nonce，挖矿的过程是不停的试随机数，使得block header取哈希后落在指定的范围之内。

​			puzzle friendly是指挖矿过程中没有捷径，为了使输出值落在指定范围，只能一个一个去试。所以这个过程还可以作为工作量证明(proof of work)。
​			挖矿很难，验证很容易。(difficult to solve ,but easy to verify)

**比特币中用的哈希函数叫作SHA-256(secure hash algorithm )以上三个性质它都是满足的。**

**在比特币系统中开账户:**
在本地创立一个公私钥匙对(public key ,private key)，这就是一个账户。公私钥匙对是来自于非对称的加密技术(asymmetric encryption algorithm)。

对称加密与不对称加密：

​		—	对称加密：私钥与公钥为同一个秘钥，前提需要有专门的安全通道将公私钥传递给通讯的双方，不好分发密钥

​		—	不对称密钥：公钥不用保密，私钥保存在本地，对方转账只需知道私钥即可

**签名：**公钥和私钥用来签名

​		A要用自己的私钥给交易签名，其他人收到这笔交易后，要用A的公钥去验证签名。签名用私钥，验证用公钥，用的仍然是同一个人的。创建账户产生相同公私钥的可能性微乎其微，所以大量创建账户来窃取其他人账户是不可行的。



##### **2.数据结构**

Hash point 、Markel Tree

**Hash Point：**如下图对于该节点，我们可以看到有两个指针指向这个节点（实际上为一个），其中P为该节点的地址，H()为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210821223310976.png" alt="image-20210821223310976" style="zoom:50%;" />

***在比特币中，其中最基本的数据结构便是一个个区块形成的区块链**



<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210821223626114.png" alt="image-20210821223626114" style="zoom:50%;" />

​		每个区块根据自己的区块内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。需要注意的是，本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容不被篡改。

​		在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户(本节点)仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。

​		一般来说，一般的链表我们都可以改造为使用哈希指针的链表，但当链表中存在环时，哈希指针便不能再使用。

**Markel Tree：**类似于Binary Tree，利用哈希指针代替了普通指针

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210821224127428.png" alt="image-20210821224127428" style="zoom:50%;" />

​		其中A、B、C、D为数据块。可见，A和B各有一个哈希值，将其合并放在一个节点中，C和D同样操作，而后，针对得到的两个节点分别取哈希，又可以得到两个新的哈希值，即为图中根节点。实际中，在区块块头中存储的是根节点的哈希值（对其再取一次哈希）。

***只需要保存Root Hash便可检测出树中TX是否被篡改**

​		在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过Markle Tree的形式组织在一起。区块本身分为两部分（block head 、block body），在块头中存在有root hash（没有交易的具体信息），块身中存在交易列表。

​		**实际用途：**Markel Proof

​		轻节点与全节点：全节点保存整个区块的内容；轻节点只保存block head，即Markel Tree中的Root Hash。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210821225727245.png" alt="image-20210821225727245" style="zoom:50%;" />

​		当需要向轻节点证明某条交易是否被写入区块链，便需要用到Markle proof。我们将交易到根节点这一条路径称为Markle proof，全节点将整个Markle proof发送给轻节点，轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。

##### **3.BTC共识协议**

**数字货币经常出现的问题：double spending attack双花攻击**

​		数字货币本身为带有签名的数据文件，可以进行复制。即：对用户来说，可以将同一货币花费两次。

​		**去中心化面临的问题：**

​		一、数字货币由谁执行，如何执行，发行多少，何时发行

​						在比特币系统中由挖矿来决定货币发行权和发行量

​		二、如何验证交易是否有效，防止双花攻击

​					区块链：记录货币的使用情况（货币的来源、出处等），保证交易的有效性。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210917222339422.png" alt="image-20210917222339422" style="zoom:40%;" />				

​		这里面有两种哈希指针。第一种为指向前面的区块，使得各个区块形成链，第二种则是为了说明比特币的来源。说明比特币的来源并非凭空捏造，可以防止双花攻击。

​		在进行交易时，需要付款人的签名和收款人的地址，在比特币系统中，该地址即为收款人的公钥的哈希进行系列处理的结果。可以将其视为银行账户，根据此进行转账交易。收款方需要知道付款方的公钥，从而验证A签名是否有效，即A需要提供自己的公钥。

​		如果所提供公钥与铸币交易中。（实际上其他节点都需要知道付款方公钥，验证交易合法性）实际中A转账时候提供的公钥需要和铸币交易中公钥对的上，这样就防止了恶意节点伪造A的公钥来“偷”走A的比特币。
​		在比特币系统中，通过执行脚本（bitCoin Scrip）实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。
​		在该图中，一个区块仅含有一个交易，实际中一个区块中包含多个交易，交易通过Markle Tree组织起来，在区块中存储。

**bitCoin 区块信息**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210917223236560.png" alt="image-20210917223236560" style="zoom:50%;" />

1、挖矿求解的问题：Hash(block header) <= target

2、Hash of previous block header只计算区块块头部分的哈希（ Merkle root hash保证了block body内容不被篡改，所以只需要计算block header即可保证整个区块内容不会被篡改）

3、区块链系统中，轻节点（只存储区块block header信息），只利用区块链，但并不参与区块链系统维护和构造。

**bitCoin共识协议**

**一、简单的投票方式(sybil attack 女巫攻击)：**

​	某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。

**存在的问题1**——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。
**存在的问题2**——无强迫投票手段，某些节点不投票（行政不作为）。
**存在的问题3**——网络延迟事先未知，投票需要等多久？效率上会产生问题。
	更大的一个问题——membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击）。所以，这种简单的投票方案也是不可行的。

**二、基于算力的投票：**

​	比特币系统依据计算力进行投票，每一个节点都可以自行组装一个候选区块，不断尝试各种nonce值(挖矿，H(block header)<=target)，当某一个节点找到符合要求的nonce，便获得了记账权，将区块发布到系统中，其他节点验证区块的合法性，若大部分通过，则将其加入到区块链。

​	基于算力竞争，且即使产生很多的公私钥对，但是hash rate是不变的，只取决于计算机的算力，有效避免了女巫攻击。

​	**新出现的问题：**

​	**1、分叉攻击：**

​	<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210919115005874.png" alt="image-20210919115005874" style="zoom: 33%;" />

​		A用户对上面的A转账给B的记录回滚，从而非法获取利益。在两条链上，发现交易都合法。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。

​		但在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。

​	**2、分叉问题：**

​		在区块链正常运作情况下，也会出现分叉情况，当两个节点同时获得记账权时，会有两个等长的合法链，在缺省的条件下，节点接收最先听到的区块，该节点会沿着该区块继续延续，随着时间的延续，必然有一个链胜出，保证了区块链的一致性，被丢弃掉的区块叫做orphan block。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210919120126835.png" alt="image-20210919120126835" style="zoom:40%;" />

**bitCoin激励机制**

​	一个获得合法区块的节点，可以在区块链中加入一个特殊交易，即铸币交易(铸币交易是唯一一种产生新比特币的途径)

​	(比特币系统设计规定，起初每个区块可以获得50个比特币，但之后每隔21万个区块，奖励减半)

##### **4.bitCion实现**

**UTXO(Unspend Transaction Output)数据结构**:

​	区块链是一个去中心化的账本，比特币采用了transaction-based ledger **基于交易的账本模式** 。然而，系统中并无显示记录账户包含比特币数，实际上其需要通过交易记录进行推算。在比特币系统中，全节点需要维护一个名为 **UTXO(Unspent Transaction Output尚未被花掉的交易输出)** 的数据结构。

​	UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出。

​	为了防范“**双花攻击**”，判断一个交易是否合法，要查一下想要花掉的BTC是否在该集合中，只有在集合中才是合法的。如果想要花掉的BTC不在UTXO中，那么说明这个BTC要么根本不存在，要么已经被花过。所以，全节点需要在内存中维护一个UTXO，从而便于快速检测double spending（双花攻击）

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210923084024597.png" alt="image-20210923084024597" style="zoom:40%;" />

​	A转给B5个BTC，之后B将其转给D，则UTXO中会删掉A->B这一交易记录，同时会添加B->D这一交易记录

​	**Transaction fee(交易费)**：

​	每个交易可以有多个输入，也可以有多个输出，但输入之和要等于输出之和（total inputs = total outputs）。

​	存在一些交易的total inputs 略大于 total outputs，这部分差额便作为交易费，给了获得记账权的节点。

​	**区块中保存交易记录，如果仅仅设置出块奖励，那么，会不会存在节点只想发布区块获得出块奖励而不想打包交易？**
​	因此，BTC系统设计了Tranction fee（交易费），对于获得记账权节点来说，除了出块奖励之外，还可以得到打包交易的交易费。但目前来说，交易费远远小于出块奖励。等到未来出块奖励变少，可能区块链的维护便主要依赖于交易费了。

​	BTC系统中每21万个区块，BTC出块奖励减半，BTC系统平均每10分钟出一块，基本上出块奖励每4年减半。

​	**挖矿：**区块哈希与前一区块哈希都是以一长串0开头的，挖矿本身就是尝试各种nonce，使得产生的区块哈希值小于等于目标阈值。该目标阈值，表示成16进制，就是前面含有一长串的0。

​	nonce是一个32位的无符号整型数据，在挖矿时候是通过不断调整nonce进行的，但可以看到，nonce的取值最多为2^32 (2的32次方)种。但并非将这些nonce全部遍历一遍，就一定能找到符合要求的nonce。由于近年来，挖矿人员越来越多，挖矿难度已经调整的比较大了，而2^32这一搜索空间太小，所以仅调整nonce很大可能找不到正确的结果。可以通过修改Merkle Tree的根哈希值来进行调整。

​	**挖矿过程的概率分析：**

​	挖矿本质上是不断尝试各种nonce，来求解这样一个puzzle。每次尝试nonce，可以视为一次伯努利试验。挖矿便是多次进行伯努利试验，且每次随机。这些伯努利试验便构成了a sequence of independent Bernoulli trials(一系列独立的伯努利试验)。根据概率论相关知识知道，伯努利试验本身具有无记忆性。也就是说，无论之前做多少大量试验，对后续继续试验没有任何影响。

​	对于挖矿来说，便是多次伯努利测试尝试nonce，最终找到一个符合要求的nonce值，采用泊松分布进行近似，即系统出块时间服从指数分布。

​	<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210923091105757.png" alt="image-20210923091105757" style="zoom:40%;" />

​	系统平均出块时间为10min，该时间为系统本身设计，通过难度调整维护其平均出块时间。指数分布本身也具有无记忆性。也就是说，对整个系统而言，已经过去10min，仍然没有人挖到区块，那么平均仍然还需要等10min（很不符合人的直觉）。也就是说，将来要挖多久和已经挖多久无关。

**bitCoin总量计算：**

​	比特币系统中已经挖出来以及未被挖出来的比特币总数为2100万个。比特币的挖矿行为并非在解决数学问题，而是单纯的算力比拼。也就是说，挖矿这一过程并没有实际意义，但挖矿这一过程，却是对比特币系统的稳定起到重要维护作用。所以，只要大多数算力掌握在好的节点手中，便能够保障比特币系统的稳定。

​	当后期出块奖励趋于0时，整个比特币系统依赖于交易费运行，届时交易费将成为维护比特币系统运行的重要保证。

**bitCoin系统安全性分析：**

​	**1.恶意节点是否可以将其他账户上的比特币转给自己？**

​			不能。因为转账交易需要签名，恶意节点无法伪造他人签名。加入其获得记账权并硬往区块中写入该交易，大多数用户会认为其是一个非法区块，大多数算力将不认可该区块，从而沿着其他路径挖矿，随着时间推移，拥有大多数算力的诚实的节点将会仍然沿着原来区块挖矿，从而形成一条“最长合法链”，该区块变成孤儿区块。对于攻击者来说，不仅不能偷到其他人的比特币，而且得不到出块奖励，还浪费了挖矿花费的电费等成本。

​	**2.可否将已经花过的币再花一次(分叉攻击)？**

​		**如何防范？**

​			<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210923093400283.png" alt="image-20210923093400283" style="zoom:50%;" />

​		一种简单防范防范便是多等几个确认区块。比特币协议中，缺省需要等6个确认区块，此时才认为该记录是不可篡改的。平均出块时间10min，六个确认区块便需要1小时，可见等待时间还是相对较长的。

​	**3.可以故意不包含合法交易？**

​		可以等待后续区块包含。实际运行中，可能由于某段时间实际交易数太多，而一个区块包含交易数存在最大值，导致某些合法交易并未被写入区块链（等待后续区块写入）。

​	**4.selfish mining**

​		提前挖到但不发布，继续挖下去，等到想要攻击的交易等了6次确认认为安全之后将整条链发布出去，试图回滚原来记录。这种情况，需要恶意节点掌握系统中半数以上算力才行，否则无法成为最长合法链。

##### 5.BTC_网络工作原理

​	用户将交易发布到比特币网络上，节点收到交易后打包到区块中，再将区块发布到比特币网络上，新发布的交易以及区块如何在比特币网络上传播？

**比特币网络的工作原理：**

​	比特币工作于网络**应用层**，其底层（**网络层**）是一个P2P Overlay network（P2P覆盖网络）。比特币系统中所有节点完全平等，不像一些其他网络存在超级节点(super node)。要加入网络，至少需要知道一个种子节点，通过种子节点告知自己它所知道的节点。节点之间的通信采用了TCP协议，便于穿透防火墙。当节点离开时，只需要自行退出即可，其他节点在一定时间后仍然没有收到该节点消息，便会将其删掉。

```
P2P网络(peer-to-peer)
P2P 网络不同于传统的客户端/服务端(client/server,C/S)结构，P2P 网络中的每个节点都可以既是客户端也是服务端
特性：
	1.网络中节点的可扩展性
		在P2P网络中，节点可以随意的添加和删除。新的节点添加到网络中，一般通过种子节点接入网络，同时种子节点将新节点广播给其他节点并进行连接。
	2.去中心化
		在P2P网络中，不存在客户端与服务器这样的严格区分，同时每个节点又充当着客户端和服务器。各个节点之间是平等的，只要接入网络，任意节点都能够将消息通知给网络中的每个节点。
	3.容错性高
		此处的容错性是指整个网络的容错性，不是指单个节点的容错性高。因为任何节点的宕机都不会影响消息在网络中的传播
	4.最终一致性
		不论节点加入到网络中的时间早晚，其数据的状态最终都会达到与其他节点相同的状态。只是达到最终一致性的时间点是无法证明的
```

**比特币网络设计原则：**简单、鲁棒(最坏情况下能达到最优状况，即健硕性)而非高效

​	每个节点维护一个邻居节点集合，消息传播在网络中采用洪泛法，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息。邻居节点选取随机，未考虑网络底层拓扑结构，也与现实世界物理地址无关。该网络具有极强鲁棒性，但牺牲了网络效率。

​	比特币系统中，每个节点要维护一个等待上链的交易集合。第一次听到交易，若是合法交易，则将其加入该交易集合并转发给邻居节点，以后再收到该交易就不再转发（避免网络上交易无线传输）。假如网络中存在两个冲突交易，如交易1：A->B,交易2：A->C（假设花费的同一笔钱）。具体接收哪个取决于节点先接收到哪个交易，之后收到另一个交易会将其放弃。

​	假如某个节点先听到A->B，但又听到A->C已经上链，则此时A->B为非法交易，所以要再等待上链交易集合中删除A->B。

​	新发布区块在网络中传播方式与新发布交易传播方式类似，每个节点除检查该区块**内容是否合法**，还要检查**是否位于最长合法链**上。区块越大，则网络上传输越慢。BTC协议对于区块大小限制为不大于1M大小。

​	比特币网络传播属于 **Best effort（尽力而为）** ，不能保证一定传输成功。以一个交易发布到网络上，未必所有节点都能收到，也未必所有节点收到交易顺序都一致。

##### 6.BTC_挖矿难度

​	在比特币系统中，区块链的出块时间保持在平均10min左右。毫无疑问的是，伴随着参与挖矿的人增多，系统总算力不断增强，挖矿的难度绝对不能一成不变。实际上，在比特币系统开发过程中，中本聪便考虑到了这个问题，并设计了一个相应的难度调整算法。

​	**调整挖矿难度的目的：**

​	挖矿本质上就是不断调整block header中的nonce值，使整个block header的哈希值小于等于给定的目标阈值。即：H(block header)<=target.（target便是目标阈值，target越小，目标难度就越大）对于挖矿难度的调整，可以视为调整目标空间在整个输出空间中所占比例大小。

​	比特币系统才采用的是哈希算法SHA-256，整个输出空间大小为2^256，调整目标空间所占的比例（需要目标值前有几个0）。

```
difficult = difficult_1_target / target
```

​	挖矿难度与目标阈值成反比，其中difficult_1_target为挖矿难度为1的时候的target，即最小挖矿难度。

​	**1.如果不调整挖矿难度会怎样？**

​	系统总算力越来越强，若挖矿难度保持不变，则出块时间会越来越短。

​	**2.出块时间越来越短是好事吗？**

​	区块在网络上传播具有时延，假如出块时间为1秒，但网络传播需要10秒，则会使得系统中节点经常性处于不一致的状态，增加了系统不稳定性，且系统经常性位于分叉状态（不仅二分叉，乃至多分叉）。分叉过多，则不利于系统达成共识，且会造成算力分散，使得黑客攻击成本大大降低(不再需要整个系统51%的算力)。

​	**3.10min的出块时间是最优吗？**

​	不一定，但是可以确定的是系统的出块时间需要维持在一个定值附近，对于一个交易系统来说，10min这样一个交易时间是比较长的。但对于跨国交易来说，这个时间反而大大缩短了交易时间，减少了相应成本。

**比特币系统如何调整挖矿难度：**

​	在BTC协议中规定，每隔2016个区块需要调整一次难度，根据10min产生一个新区块可以得到，大概需要14天的时间，调整公式如下：

```
target = target * actual time / expected time
```

​	时间时间比较长，target会比较大，从而挖矿难度会降低；如果实际时间比较短，target会比较小，相应的挖矿难度会增大。target的上调和下调都是有4倍的限制。

**如何让所有的矿工都愿意调整这个挖矿难度？**		

​	这一调整算法在代码中已经写入，如果有恶意节点故意不调，其所产生的区块不会被大多数诚实的节点承认。在block header中有一个nbits的域，它是对target的编码存储（target为256位，nbits为32位，也就是说block header并未直接存储target），其他节点在进行合法性验证时候会验证nbits域是否合法，不合法则对该区块不予以承认。

##### 7.BTC_挖矿

**全节点和轻节点：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210924204735925.png" alt="image-20210924204735925" style="zoom:50%;" />

​	在比特币网络中，大多数节点都是轻节点。如果只是想进行转账操作，不需要挖矿，就无需运行一个全节点。在挖矿过程中，如果监听到别人已经挖出区块延申了最长合法链，此时应该立刻放弃当前区块，在本地重新组装一个指向最后这个新合法区块的候选区块，重新开始挖矿。

​	**1.放弃当前区块是否可惜？**

​	实际上并不可惜，挖矿本身并无记忆性，前面无论挖多久，对后面继续挖矿没有影响

​	**2.比特币系统如何保证安全性？**

​	一、密码学的保证：保证别人没有自己的私钥，就无法伪造其合法签名，从而无法从BTC账户转走。

​	二、共识机制：保证了恶意交易不被系统承认。

**挖矿设备演化：**

​	挖矿设备逐渐趋于专业化，其经历了三个过程，总体趋势从通用到越来越专用。普通CPU -> GPU ->ASIC芯片（挖矿专用矿机）。

​	很明显，ASIC芯片并不是普通人可以参与的，一定程度上提升了挖矿的门槛，违背了比特币系统**去中心化**的初衷。理想状态下，所有人用CPU挖矿，这样只要有一台家用计算机便可以参与挖矿。

**大型矿池的出现：**

​	挖矿另一个趋势便是大型矿池的出现。对于单个矿工来说，即使使用了ASIC矿机，其算力在整个系统中仍然只占据很少一部分，即使从平均收益看有利可图，但收入很不稳定。此外，单个矿工除挖矿还要承担全节点其他责任，造成了算力的消耗。

​	<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210924205715968.png" alt="image-20210924205715968" style="zoom:50%;" />

**矿池：**矿工只需要不停计算哈希值，而全节点其他职责由矿主来承担。ASIC芯片只能计算哈希值，不能实现全节点其他功能。此外，矿池出现解决了单个矿工收益不稳定的问题。当获得收益后，所有矿工对收益进行分配，从而保证了收益的稳定性。

**矿池一般有两种组织形式：**

​	1.类似于大型数据中心(同一机构)，集成成千上万矿机进行哈希计算。

​	2.分布式，矿工与矿主不认识，矿工与矿主联系，资源加入其矿池，矿主分配任务，矿工进行计算，获得收益后将整个矿池中所有的矿工进行利益分配。

**51%算力的矿池可以发动的攻击**

​	1、分叉攻击：对已经经过6次确认的交易分叉，利用51%的算力分叉将交易记录回滚。

​	2、封锁交易(Boycott):

​		假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。

**矿池出现的优劣：**

优点：解决了矿工收入不稳定的问题，减轻了矿工的负担。
缺点：威胁到了区块链系统的安全，使得51%攻击变得容易起来。	

##### 8.BTC_脚本

​	比特币系统中使用的脚本语言非常简单，唯一可以访问的内存空间只有栈，所以也被称为“基于栈的语言”。

**交易结构**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210925102700854.png" alt="image-20210925102700854" style="zoom:50%;" />	

**vin内容**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210925102632953.png" alt="image-20210925102632953" style="zoom:50%;" />

**vout内容**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210925102853133.png" alt="image-20210925102853133" style="zoom:50%;" />

**输出输入脚本的执行**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210925103335040.png" alt="image-20210925103335040" style="zoom:50%;" />

**输入输出脚本的几种形式：**

**1.PAPK形式(Pay to public key)**

特点：输出脚本直接给出收款人公钥

```
input script:
	PUSHDATA(sig)
output script:
	PUSHDATA(PubKey)
	CHECKSIG //检查签名操作
```

**执行流程：**

​	首先将签名(sig)压入栈；后将公钥压入栈；弹出两个元素，用公钥检查签名的正确性，正确返回True。

**2.P2PKH形式(Pay to public key hash)—最常用**

特点：输出脚本不直接给出收款人公钥，而是公钥的哈希。

```
input script:
	PUSHDATA(sig)
	PUSHDATA(Pubkey)
output script:
	DUP
	HASH160
	PUSHDATA(PubKeyHash)
	EQUALVERIFY
	CHECKSIG
```

**执行流程：**

​	1.将签名压入栈

​	2.将公钥压入栈

​	3.将栈顶元素复制一遍

​	4.栈顶元素弹出，取hash，并将哈希值压入栈(当前hash为input脚本中公钥通过HASH160求算的hash)

​	5.输出脚本提供的公钥哈希值压入栈

​	6.弹出栈顶两个元素(两个hash值)，比较是否相等(4、5、6操作的目的为防止冒名顶替公钥)

​	7.用公钥检查签名是否正确，正确返回True

**3.P2SH形式(Pay to script Hash)**

应用场景：对多重签名的支持

特点：输出脚本给出的不是收款人公钥的哈希，而是收款人提供的一个脚本的哈希。该脚本称为redeemScript,即赎回脚本。等未来花钱的时候，输入脚本要给出redeemScript的具体内容以及可以使之正确运行需要的签名。

```
采用BIP16的方案
input script:
	...
	PUSHDATA(sig)
	...
	PUSHDATA(serialized redeemScript)
output script:
	HASH160
	PUSHDATA(redeemScriptHash)
	EQUAL
```

验证过程：
	1.验证序列化的redeemScript是否与output script中哈希值匹配。
	2.反序列化并执行redeemScript，验证iutput script中给出签名是否正确。（将赎回脚本内容当作操作指令执行一遍）

**实例：**

```
redeemScript:
	PUSHDATA(Pubkey)
	CHECKSIG
	
input script:
	PUSHDATA(sig)
	PUSHDATA(serialized redeemScript)
output script:
	HASH160
	PUSHDATA(redeemScriptHash)
	EQUAL
```

执行流程：

​	**第一阶段的验证：执行拼接后的输入输出脚本**

​	1.输入脚本的签名入栈

​	2.赎回脚本入栈

​	3.对栈顶元素去哈希

​	4.输出脚本给出的赎回脚本哈希值入栈

​	5.比较栈顶两个元素是否相等，若相等都出栈

​	**第二阶段的验证：执行反序列化后的赎回脚本**

​	1.将PubKey压入栈

​	2.验证输入脚本给出签名的正确性

**多重签名：**

**早期多重签名实现：**

​	通过CHECKMULTISIG来实现，其中输入脚本提供N个签名，输出脚本给出N个公钥和阈值M，表示N个人至少有M个签名即可实现转账(N>=M)。输入脚本只需要提供N个公钥中M个合法签名即可。

```
input script:
	PUSHDATA(sig_1)
	PUSHDATA(sig_2)
	...
	PUSHDATA(sig_M)
output script:
	M
	PUSHDATA(pubkey_1)
	PUSHDATA(pubkey_2)
	...
	PUSHDATA(pubkey_N)
	N
	CHECKMULTISIG
```

**执行过程：**

​	1.输入脚本M个签名压入栈

​	2.阈值M压入栈

​	3.N个公钥压入栈

​	4.N值，压入栈

​	5.执行CHECKMULTISIG，是否栈中有N个公钥对应签名中的M个，若是，验证通过

**利用P2SH实现多重签名**

```
redeemScript:
	M
	PUSHDATA(pubkey_1)
	PUSHDATA(pubkey_2)
	...
	PUSHDATA(pubkey_N)
	N
	CHECKMULTISIG
	
input script:
	PUSHDATA(sig_1)
	PUSHDATA(sig_2)
	...
	PUSHDATA(sig_M)
	PUSHDATA(serialized RedeemScript)
output script:
	HASH160
	PUSHDATA(RedeemScriptHash)
	EQUAL
```

执行过程：

​	**第一阶段验证：**输入输出脚本执行

​	1.将false(占位)压入栈，解决checkmultisig引入的bug

​	2.将M个签名压入栈

​	3.序列化的赎回脚本，作为数压入栈

​	4.取哈希

​	5.输出脚本提供的哈希值入栈

​	6.判断两个hash是否相等

​	**第二阶段验证：**赎回脚本

​	1.M压入栈

​	2.N个公钥和N压入栈

​	3.检查多重签名正确性

**一个特殊的脚本：**

​	以RETURN开始，后面可以跟任何内容。RETURN操作，无条件返回错误，所以该脚本永远不可能通过验证。执行到RETURN，后续操作不会再执行。n该方法是销毁比特币的一种方法。

##### 9.BTC_分叉

​	分叉指的是，原来的系统中为一条链，但分成了两条链。分叉形成的原因可能有多种，

​	1、挖矿时两个节点差不多同时挖出矿，都会发布区块(对比特币系统当前状态产生分歧导致的分叉——**state fork**)；

​	2、分叉攻击，同样也会导致分叉(**forking attack**，人为故意造成)；

​	3、比特币协议改变，在分布式系统中不能保证所有节点同时升级软件，假设存在少数节点未升级，导致出现分叉(**protocal fork**)；

​	根据对比特币协议修改的不同，又可以将分叉分为硬分叉和软分叉

**硬分叉（hard fork）**

​	对比特币协议增加新协议，扩展新功能，未升级软件的旧节点会不认可这些修改，会认为这些特性是非法的。这也就是对比特币协议内容产生分歧，从而导致分叉。

​	**经典案例：对比特币区块大小的修改**

​	在BTC系统中，区块大小最大为1MB，可以包含的交易最大数量为4000笔左右。而一个区块产生大概需要10min左右，也就是说，整个比特币系统，平均每10分钟最多只能处理4000笔交易(平均每秒7笔交易)，相比目前银行等金融机构每秒数十万数百万的交易量来说，根本不在一个数量级上，严重影响吞吐率和交易处理(即上链)时间(因为交易太多，无法写入只能等待下一个区块)。

​	所以，有人便认为可以增大区块大小，使得一个区块中可以包含的交易数量增多，假设将区块大小从1MB增大至4MB。假设系统中大多数节点更新了软件，少数节点仍然遵从1MB限制的协议。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210925212241212.png" alt="image-20210925212241212" style="zoom:40%;" />

​	在改变区块大小后，新节点兼容新旧两种大小的区块；而旧节点只承认旧大小的区块，就出现了新节点永远沿着上面的链挖矿，旧节点永远沿着下面的链挖矿，由于新节点算力足够强，所以形成两条永远都在延伸且平行的链。当然，上面的链，也有可能会挖出大小在1MB内的小区块，但对旧节点来说，该链上存在非法区块，不会认可该链。可见，这种分叉是持久性的。

**软分叉（soft fork）**

​	对BTC协议添加限制，使得原本合法交易在新交易中不合法，便会形成软分叉

​	**经典案例：**

​		假设将区块大小从1MB减小至0.5MB(实际中，1MB已经足够小，不会调小了)。假设系统中大多数节点更新了软件，少数节点仍然遵从1MB限制的协议(注意，这里大多数和少数是按照算力来区分的，和账户数量无关)。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210925220351042.png" alt="image-20210925220351042" style="zoom:50%;" />

​		软件更新（改变区块大小），新节点不兼容旧节点大小的区块，但对于旧节点不承认新节点挖出的块，则会分叉，以后只要发现有旧节点大小的区块上链就会分叉，这样导致旧节点挖出块一直被抛弃。

​	对于系统来说，不会存在永久性分叉。

**总结：**

​	soft fork：只要系统中拥有半数以上算力节点更新软件，系统就不会产生永久性分叉

​	hard fork：必须系统中所有节点更新软件，系统才不会产生永久性分叉

##### 10.BTC_阶段总结问答

​	**1.转账交易时候，如果接受者不在线会怎样？**

​	转账交易只需要在区块链上记录，将某账户比特币转到另一账户，只需要知道对方私钥的hash值即可转账，不需要对方在线上。

​	**2.假设某全节点收到某个转账交易，会不会有可能转账交易中收款人地址该全节点从未听过**

​	可能，比特币账户在只需要在本地产生即可，只有该账户第一次收到转账时，其他节点才可能知道该节点的存在。

​	**3.如果账户私钥丢失怎么办？**

​	没有办法解决，比特币为去中心化货币，并没有第三方机构可以重置密码，该账户中的余额会一直存储在UTXO中，永远取不出来。

​	**4.私钥泄密怎么办？**

​	需要尽快将剩余的BTC转到其他安全账户上，没有第三方中心机构重置密码或冻结账户。BTC系统中账户便是公私钥对，密码就是私钥，无法更改。

​	**5.账户写错地址怎么办？**

​	没有办法，一旦交易已经发出，无法回滚。但是可以通过线下联系改地址的是否可以退回，若该地址为一个不存在的地址，该次交易的费用将永远存储在UTXO中，这对全节点来说是不友好的。

​	**6.在BTC脚本中介绍了OP_RETURN指令，我们提到，这种方法为普通用户提供了一个向比特币网络中写入想要一直保存的内容。但OP_RETURN执行结果是无条件返回错误，而交易返回错误，区块又怎么会包含它？区块链又如何会接收这个区块？**

​	OP_RETURN实际写在当前交易的输出脚本中，而验证交易合法性时，使用的当前交易的输入脚本和前一个交易(币来源的交易)的输出脚本进行验证。也就是说，验证当前交易合法性时，并不会执行该语句。只有在有人想花这笔钱时候，才会执行该语句。

​	**7.BTC挖矿，存在某个矿工发现其他矿工发布了nonce，收到后验证该区块合法，将该nonce作为自己找到的nonce发布出去？**

​	实际上是不可能的，发布的区块中包含铸币交易，其收款人地址为挖到矿的矿工地址，如果要偷答案，需要修改该收款人地址，然而更改地址后将会改变MerkleTree的根哈希值，从而导致nonce作废。

​	**8.交易费是交易者为了自己交易可以上链而给出的“小费”，那么如何得知哪个矿工可以挖到矿？**

​	事先无需知道谁会挖到矿，交易中总输入和总输出差额就是交易费。哪个矿工挖到矿，在打包交易时，可以将这些交易费收集起来作为自己获得的交易费。

##### 11.BTC_匿名性

​	一般来说,匿名性多与隐私保护相关。但实际上，比特币中的匿名并非真正的匿名，而是假的匿名。实际上，比特币与纸币相比，纸币的匿名性更好，因为其并没有对个人信息的标记。也正是因为其匿名性，很多非法交易采用现金交易。但现金存在保管、运输等各个方面的不便。

​	实际上，比特币中的数据是完全公开的，而网上的交易是要与实体世界进行交易的，所以大大破坏了其匿名性。假如银行允许用假名，由于银行数据并非公开，所以银行系统的匿名性是要比比特币更好的。

**BTC系统中什么情况会破坏其匿名性**

​	**1、用户可以在本地产生多个地址账户，但是这些地址账户可以被关联起来**

​		表面上看，每次交易可以更换公私钥对，从而每次都是新的账户，具有很强的匿名性。但实际上，这些账户在一定情况下，是可以被关联起来的。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20210929083600792.png" alt="image-20210929083600792" style="zoom:50%;" />	

​	该图中的交易有两个输入和两个输出，addr1和addr2很可能是同一个人所持有的账户，可能因为一个账户的bitCoin不够，需要利用自己的另一个账户进行转账；在输出中，很有可能有一个地址是属于找零的地址。addr4明显是该用户找零的地址。

​	**2、地址账户与个人真实社会中的身份有可能产生关联**

​		任何使得BTC和实体世界中关联的操作都有可能泄露用户真实身份，其中最明显的就是资金的转入转出。要得到BTC，如果用钱买，就会与实体世界进行交互。想要将BTC转为现实中的货币，也同样需要与实体世界交互。

​	**3、进行bitCoin支付的时候**

​		在线下进行支付时候，和个人账户建立了联系，从而会泄露掉个人信息。

**BTC如何提高匿名性？**

​	**从应用层看**，可以将各个不同用户的BTC混合在一起，使得追查变得混乱(Coin mixing)；

​	**从网络层看**，可以采用多路径转发的方法，数据不直接发送出去，而是经过很多跳(洋葱路由 The Onion router 的基本思想)。

```
洋葱路由
	从应用层看，可以将各个不同用户的BTC混合在一起，使得追查变得混乱(Coin mixing)；从网络层看，可以采用多路径转发的方法，数据不直接发送出去，而是经过很多跳(洋葱路由的基本思想)
```

**零知识证明：**

​	**定义：**一方（证明者）向另一方（验证者）证明某一个陈述是正确的，但不需要透露除该陈述是正确的之外的任何信息。

​	例如：A想要向B证明某一账户属于A，这说明A知道该账户的私钥。但不可能通过A公布私钥的方法来证明，该账户确实属于A。因此，A可以产生一个账户签名，B通过公钥对签名进行验证。(实际上该证明是否属于零知识证明存在争议，因为泄露了用私钥产生的签名)

**同态隐藏**：

​	**三个性质：**

​		1.如果x,y不同，那他们的加密函数值E(x)和E(y)也不相同

​		2.给定E(x)的值，很难反推出x的值

​		3.给定E(x)和E(y)的值，可以很容易的计算出某些关于x,y的加密函数值

​			同态加法：通过E(x)和E(y)计算出E(x+y)的值

​			同态乘法：通过E(x)和E(y)计算出E(xy)的值

​			扩展到多项式

**盲签：**

​	盲签名是一种特殊的数字签名技术。盲签名因签名的人看不到所签署文件的具体内容而闻名，它有两个显著的特点：一是签名者对消息的内容是不可见的 ;二是签名被公开后，签名者不能追踪签名。

**零币和零钞：**

​	零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码学保证

​	零币系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务。

​	零钞系统使用zk-SNARKs协议，不能依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。

​	**实现：**零币在花费的时候，只需要用零知识证明来证明所花掉的币是系统中存在的某一个合法的币，但不用透露具体花掉的是系统中哪一个币。这样就破坏了关联性。这类货币并非主流加密货币，因为其为了设计匿名性，付出了一定代价，而且，需要强匿名性的用户并不多。

​	从数学上看，零币和零钞是安全的。但其并不是百分之百的匿名，其并未解决与系统外部实体发生交互时对匿名性的破坏。

##### 12.BTC_思考

**1.哈希指针**

​	所谓哈希指针，只是系统中一种形象化的方法。实际应用时候，只有哈希而没有指针。

​	在blockHeader中只有hash值，没有hash指针，**如何查找前一个区块的内容？**

​	全节点一般将区块存储于一个key-value数据库中，key为哈希，value为区块内容。常用的key-value数据库为levelDB，只要掌握到最后一个区块的哈希值即可依据哈希值一直往前找到区块链所有内容。有些节点只保存区块链部分信息，如果需要用到前面的区块，可以问其他节点要。哈希指针性质保证了整个区块链内容是不可篡改的。

**2.区块恋**

​	有情侣一起买BTC，将私钥从中截断，每人保留其中一部分。如果未来两人依旧感情很好，就可以将钱取出；如果分手，这部分钱就会永久锁死，谁也无法取出，通过区块链的不可篡改性作为两人的爱情见证。
​	如果按照这种方法，将私钥分为N份，但会有一系列问题。

​		**一.** 如果N个人中任意一个人忘记私钥，则无法将钱取出。

​		**二.**截断私钥长度，会降低安全性，因为私钥长度会直接影响破解难度(2^256 远远大于 2^128)，之间难度差距远远不止一倍。对于多个人账户，应该使用多重签名，而非截断私钥的方法。

​		**三.**如果分手，该钱变成死钱，一直保存在UTXO集合中，对矿工不友好。

**3.分布式共识**

​	从理论上来说，分布式系统不可能达成共识，但是理论和实际存在差异，不可能结论只针对某一些模型情景。

​	***肖老师语录：知识改变命运，这句话本身没有错，但是对知识的一知半解可能让你的命运变得更差，搞科研是很有意义的，但是不要给学术界的思维限制头脑，不要为程序员的思维限制想象力。**

**4.BTC的稀缺性**

​	挖矿有收益，且收益大于开销。早期BTC难度低且出块奖励高，从而吸引矿工。

​	BTC总量固定，有人认为其是一个精妙的设计。但实际上，总量固定的东西并不适合作为货币，这也就决定了BTC并不能在未来完全颠覆现有货币体系。
**5.量子计算**

​	BTC这种建立在密码学上的加密货币，在量子计算出来后会不会变得不安全。

​	**一.** 量子计算距离使用仍然有很长距离
​	**二.** 量子计算若真正使用到破坏现有加密算法，对传统金融业的破坏无疑是最大的。
​	**三.** 实际中使用的并非公钥，而是使用公钥哈希。哈希函数一般都是不可逆的，所以即使量子计算也无法反推私钥。BTC中用的SHA-256，无论输入多大，最终结果都为256位，必然会导致信息丢失，无法反推原本数据。



#### Part Two Ethereum

##### 1.ETH_概述

​	BTC称为区块链1.0，以太坊称为区块链2.0。以太坊对比特币设计中存在的不足进行了改进，比如出块时间、共识协议、mining puzzle等。以太坊还会加入权益证明(POS)代替工作量证明(POW)，也会增加对智能合约(smart contract)的支持。

**去中心化的合约**

​	现实生活中，经常提到“契约”或“合约”。合约的有效性是需要政府进行维护的，如果产生纠纷需要针对合法性合同进行判决。ETH的设计目的就是，通过技术手段来实现取代政府对于合约的职能。

​	好处：若合同签署方并非一个国家，没有统一的司法部门（众筹）。如果可以编写无法修改的合约，所有人只能按照相关参与方执行，无法违约。

##### 2.ETH_账户

​	BTC系统是基于交易的账本，系统中并未记录每一个账户有多少余额，只能通过UTXO进行推算，不符合实际思维，但是隐私性较好。

​	此外，账户中的BTC在花的时候必须一次性全部花出去，所以需要额外账户地址接受余额。





​	ETH系统采用了基于账户的模型，与现实中的银行账户相似，系统中记录了每一个账户ETH的数量，用户进行转账时只需要查看该用户的账户余额是否支持该笔交易，同时也不需要每次全部转账，这天然的防范了double spending attack(每创建一次交易，就判断账户余额后扣一次ETH，不存在双花)。但是存在replay attack。

​	**replay attack（重放攻击）**

​	账户A向账户B转账，过一段时间后，B将A的交易重新发布，导致A账户被扣款两次。

​	**解决：**在用户状态树中添加nonce计数器，用于记录账户交易的次数，转账时nonce将一起被写入交易内容中，并受转账账户签名的保护。在系统全节点中的状态数中维护了账户余额以及nonce计数器等内容，若重放上一次交易信息，发现nonce值相同则不会被接受，从而防止重放攻击。

**ETH账户：外部账户&合约账户**

​	1.externally owned account（外部账户）：类似于BTC系统中在本地生成公私钥对，可以主动发起交易，存在balance（用户余额）以及nonce（计数器）。

​	2.smart contract account（合约账户）：不通过公私钥对控制，不能主动发起交易，只能收到外部账户调用后才发起交易或调用其他合约账户，除balance以及nonce还存在code（代码）以及storage（相关状态-存储）。

​	创建合约的时候会返回一个地址，可以对其进行调用，调用过程中，代码不会但是状态会变化。

##### 3.ETH_数据结构

###### 状态树

​	以太坊采用基于账户的模式，系统中记录了每一个账户的余额，以太坊采用状态树实现对数据的管理。

​	首先需要实现账户地址到账户状态的映射，在以太坊中，账户地址为160字节，表示为40个16进制数额（一位16进制数用二进制表示是xxxx）。状态包含了余额(balance)、交易次数(nonce),合约账户中还包含了code(代码)、存储(stroge)。

​	直观地来看，其本质上为Key-value键值对。

​	保存Key-value对，key就是账户地址，而value状态通过RLP(Recursive Length Prefix，一种进行序列化的方法)编码序列号之后再进行存储。

**构建状态树的前期猜想**

​	**哈希表实现账户状态存储？**

​	直观想法便用**哈希表**实现。若不考虑哈希碰撞，查询直接为常数级别的查询效率。但采用哈希表，难以提供Merkle proof。

​	**Merkle Tree实现哈希表内容的记录？**	

​	但当新区块发布，哈希表内容会改变，再次将其组织为新的Merkle Tree，但每当产生新区块(ETH中新区块产生时间为10s左右)，都要重新组织Merkle Tree，很明显这是不现实的。在ETH中，Merkle Tree来组织账户信息，很明显其会越来越庞大。实际中，发生变化的仅仅为很少一部分数据，每次重新构建Merkle Tree代价很大。

​	**Merkel Tree？**	

​	实际中，Merkle Tree并未提供一个高效的查找和更新的方案。此外，将所有账户构建为一个大的Merkle Tree，为了保证所有节点的一致性和查找速度，必须进行排序。

​	**Sorted Merkle Tree？**

​	新增账户，由于其地址随机，插入Merkle Tree时候很大可能在Tree中间，发现其必须进行重构。所以Sorted Merkle Tree插入、删除(实际上可以不删除)的代价太大。

**ETH采取的状态树数据结构：MPT(Modified (Merkle) Particia tree)**

**trie(字典树/前缀树)**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211003215226479.png" alt="image-20211003215226479" style="zoom:50%;" />

特点：
	1.trie中每个节点的分支数目取决于Key值中每个元素的取值范围(图中最多26个英文字母分叉+一个结束标志位)。

​	2.trie查找效率取决于key的长度。实际应用中（以太坊地址长度为160byte）。
​	3.理论上哈希会出现碰撞，而trie上面不会发生碰撞。
​	4.给定输入，无论如何顺序插入，构造的trie都是一样的。
​	5.更新操作局部性较好
缺点：
​	trie的存储浪费。很多节点只存储一个key，但其叶节点只有一个，过于浪费。

**Particia trie**	

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211003215913861.png" alt="image-20211003215913861" style="zoom:50%;" />

​	Patricia trie就是进行了路径压缩的trie。如果新插入单词，原本压缩的路径可能需要扩展开来。

​	树中插入的键值分布较为稀疏的情况下，可见路径压缩效果较好。在以太坊系统中，160位的地址存在2^160 种，该数实际上已经非常大了，和账户数目相比，可以认为地址这一键值非常稀疏。

**MPT(Modified Merkle Particia trie)**

![image-20211003221005831](/Users/zyh/Library/Application Support/typora-user-images/image-20211003221005831.png)

​	每次发布新区块，状态树中部分节点状态会改变。但改变并非在原地修改，而是新建一些分支，保留原本状态。如下图中，仅仅有新发生改变的节点才需要修改，其他未修改节点直接指向前一个区块中的对应节点。

![image-20211003221402008](/Users/zyh/Library/Application Support/typora-user-images/image-20211003221402008.png)

​	系统中全节点并非维护一棵MPT，而是每次发布新区块都要新建MPT。只不过大部分节点共享。

​	**为何不在MPT直接修改，而要保存原来状态，重新建立MPT**

​	为了便于回滚。在挖出新区块时会产生分叉，而后上面节点胜出。那么，下面节点中状态的修改便需要进行回滚。因此，需要维护这些历史记录。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211003221551455.png" style="zoom:50%;" />

**ETH中BlockHeader信息**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211003221800746.png" alt="image-20211003221800746" style="zoom:30%;" />

**ETH中Block结构信息**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211003221932002.png" alt="image-20211003221932002" style="zoom:33%;" />

###### 交易树和收据树

​	交易树：每次发布一个区块时，区块中的交易会形成一颗Merkle Tree，即交易树。

​	收据树：每个交易执行完之后形成一个收据，记录交易相关信息。由于以太坊智能合约执行较为复杂，通过增加收据树，便于快速查询执行结果。

​	交易树和收据树上的节点是一一对应的。交易树和收据树都是MPT，MPT的好处是支持**查找操作**，通过键值沿着树进行查找即可。对于状态树，查找键值为账户地址；对于交易树和收据树，查找键值为交易在发布的区块中的序号。

​	交易树和收据树只将当前区块中的交易组织起来，而状态树将所有账户的状态都包含进去，无论这些账户是否与当前区块中交易有关系。多个区块状态树共享节点，而交易树和收据树依照区块独立。

​	用途：

​	1.向轻节点提供merkle proof

​	2.更加复杂的查找操作（查询过去十天某个账户的交易记录）

**Bloom filter（布隆过滤器）**：支持较为高效查找某个元素是否在某个集合中

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211008193121610.png" alt="image-20211008193121610" style="zoom:50%;" />

​	给定一个数据集，其中含义元素a、b、c，通过一个哈希函数H()对其进行计算，将其映射到一个其初始全为0的128位的向量的某个位置，将该位置置为1。将所有元素处理完，就可以得到一个向量，则称该向量为原集合的“摘要”。可见该“摘要”比原集合是要小很多的。
​	假定想要查询一个元素d是否在集合中，假设H(d)映射到向量中的位置处为0，说明d一定不在集合中；假设H(d)映射到向量中的位置处为1，有可能集合中确实有d，也有可能因为哈希碰撞产生误报。

​	实际部分采用一组哈希函数进行向量映射，有效避免哈希碰撞。

​	**bloom filter特点：**可能出现误报，但不会出现漏报

**ETH系统中Bloom filter的作用：**	

​	每个交易完成后会产生一个收据，收据包含一个Bloom filter记录交易类型、地址等信息。在区块block header中也包含一个Bloom filter，其为该区块中所有交易的Bloom filter的一个并集。

​	查找时候先查找块头中的Bloom filter，如果块头中包含。再查看区块中包含的交易的Bloom filter，如果存在，再查看交易进行确认；如果不存在，则说明发生了“碰撞”。
好处是通过Bloom filter这样一个结构，快速大量过滤掉大量无关区块，从而提高了查找效率。

**transaction-driven state machine（交易驱动的状态机）**

​	ETH的运行过程中，可以视为**交易驱动的状态机**，通过执行当前区块中包含的交易，驱动系统从当前状态转移到下一状态。当然，BTC也可以视为**交易驱动的状态机**，其状态为UTXO。对于给定的当前状态和给定一组交易，可以确定性的转移到下一状态(保证系统一致性)。

##### 4.ETH_GHOST协议

**前言：**

​	BTC系统中出块时间为10min，而以太坊中出块时间被降低到15s左右，虽然有效提高了系统反应时间和吞吐率，却也导致系统临时性分叉变成常态，且分叉数目更多。这对于共识协议来说，就存在很大挑战。

​	在BTC系统中，不在最长合法链上的节点最后都是作废的，但如果在以太坊系统中，如果这样处理，由于系统中经常性会出现分叉，则矿工挖到矿很大可能会被废弃，这会大大降低矿工挖矿积极性。而对于个人矿工来说，和大型矿池相比更是存在天然劣势。
对此，以太坊设计了新的公式协议——**GHOST协议**(该协议并非ETH系统原创，而是对原本就有的Ghost协议进行了改进)。

**GHOST协议**

**GHOST协议1.0（有缺陷）**

​	假定以太坊系统存在以下情况，A、B、C、D在四个分支上，最后，随着时间推移B所在链成为最长合法链，因此A、C、D区块都作废，但为了补偿这些区块所属矿工所作的工作，给这些区块一些“补偿”，并称其为"Uncle Block"（叔父区块）。

​	规定E区块在发布时可以将叔父区块包含进来，叔父区块可以得到出块奖励的7/8，而为了激励E包含叔父区块，规定E每包含一个叔父区块可以额外得到1/32的出块奖励。

​	为了防止E大量包含叔父区块，规定一个区块只能最多包含两个叔父区块，因此E在A、C、D中最多只能包含两个区块作为自己的出块奖励

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211010153742027.png" alt="image-20211010153742027" style="zoom:33%;" />

​	**缺陷：**

​	1.叔父区块最多只能包含两个，第三个甚至更多的叔父区块无法包含

​	2.存在某一个矿工故意不包含叔父区块，导致叔父区块7/8出块奖励没了，而自己仅仅损失1/32。如果甲、乙两个大型矿池存在竞争关系，那么他们可以采用故意不包含对方的叔父区块，因为这样对自己损失小而对对方损失大。

**GHOST协议2.0**

​	F为E后面一个新的区块。因为规定E最多只能包含两个叔父区块，所以E包含了A和C。此时，F也可以将D认为自己的的叔父区块(**实际上并非叔父辈的，而是爷爷辈的**)。如果继续往下挖，F后的新区块仍然可以包含B同辈的区块(假定E、F未包含完)。这样，就有效地解决了上面提到的最初Ghost协议版本存在的缺陷。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211010155030117.png" alt="image-20211010155030117" style="zoom:33%;" />

​	这样也解决了GHOST协议1.0版本的两个问题，叔父区块可以被后面的子区块包含；也不存在矿工故意不包含区块的行为，因为该叔父区块可以被主链上的下一个区块所包含，uncle reward也可以获得，而故意不包含该区块的矿工没有获得额外奖励。

​	**叔父区块相隔几代才好？**

​	M为该区块链上一个区块，F为其严格意义上的叔父，E为其严格意义上的“爷爷辈”。

​	以太坊中规定，如果M包含F辈区块，则F获得7/8出块奖励；如果M包含E辈区块，则F获得6/8出块奖励，以此类推向前。直到包含A辈区块，A获得2/8出块奖励，再往前的“叔父区块”，对于M来说就不再认可其为M的"叔父"了。

​	对于M来说，无论包含哪个辈分的“叔父”，得到的出块奖励都是1/32出块奖励。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211010155607629.png" alt="image-20211010155607629" style="zoom:50%;" />

**ETH中的奖励：**

​	BTC：静态奖励(出块奖励)+动态奖励(交易费，占据比例很小)

​	ETH：静态奖励(出块奖励+包含叔父区块的奖励)+动态奖励(汽油费，占据比例很小，叔父区块没有)

**以太坊中包含了叔父区块，要不要执行父区块中的交易？**

​	不需要，叔父区块和同辈的主链上区块有可能包含有冲突的交易。叔父区块是没有动态奖励的。因此，一个节点在收到一个叔父区块的时候，只检查该叔父区块合法性而不检查其中交易的合法性。

**对于叔父区块的子区块如何处理？**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211010160541464.png" alt="image-20211010160541464" style="zoom:50%;" />

​	如果规定将叔父区块为前驱区块的整条链作为一个整体，给予出块奖励，这一定程度上鼓励了分叉攻击(降低了分叉攻击的成本，因为即使攻击失败也有奖励获得)。因此，ETH系统中规定，**只认可A区块为叔父区块**，给予其补偿，而其后的区块全部作废。

##### 5.ETH_挖矿算法

**引言：**

​	挖矿这一过程，虽然并没有创造什么实际价值，但挖矿本身维持了比特币系统的稳定。总体来说，比特币系统中的挖矿算法较为成功，并未发现大的漏洞。但是比特币系统的挖矿算法也存在一定问题，其中最为突出的就是导致了**挖矿设备的专业化**，普通计算机用户难以参与进去，导致了挖矿中心化的局面产生，而这与“去中心化”这一理念相违背。

​	利用**Memory Hard Mining Puzzle**，即增加对内存访问的需求。从而做到ASIC Resistance

**LiteCoin挖矿算法**

​	莱特币的puzzle基于Scrypt。Scrypt为一个对内存性能要求较高的哈希函数，之前多用于计算机安全密码学领域。

​	**基本思想：**

​	1.设置一个很大的数组，按照顺序填充伪随机数（因为哈希函数的输出并不能提前预料，所以看上去就像是一大堆随机的数据，因此称其为“伪随机数”）。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211011112358484.png" alt="image-20211011112358484" style="zoom:50%;" />

​	Seed为种子节点，通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希得到的。因此这样的数组中取值存在前后依赖关系

​	2.在需要求解Puzzle的时候，按照伪随机顺序，从数组中读取一些数，每次读取位置与前一个数相关。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211011112558646.png" alt="image-20211011112558646" style="zoom:45%;" />

​	第一次，从A位置读取其中数据，根据A中数据计算获得下一次读取位置B；第二次,从B位置读取其中数据，根据B中数据计算获得下一次读取位置C；

​	**设计目的：增加内存访问，去专用化**

​	如果数组足够大，对于挖矿矿工来说，必须保存该数组以便查询，否则每次不仅计算位置，还要根据Seed计算整个数组数据，才能查询到对应位置的数据。这对于矿工来说，计算复杂度大幅度上升。

​	其核心目的为使puzzle求解的过程不仅仅进行运算，并且增加其对内存的访问，从而实现对ASIC芯片不友好。

​	**设计缺陷：轻节点验证不友好**

​	想要验证该Puzzle，也需要存储该数组，因此对于轻节点来说，并不友好(系统中绝大多数节点为轻节点)。

​	对于LiteCoin真正的应用场景，数组的大小不能设置的太大，对于计算机而言数组1G基本没影响，但是对于运行轻节点的手机APP等，1G占据空间过大。实际LiteCoin系统设计数组大小仅为128K。导致在后期该设计理念并未取到预期效果，GPU/ASIC挖矿也相继出现了。

**BTH挖矿算法：**	

​	以太坊中，设计了两个数据集，一大一小。小的为16MB的**cache**，大的数据集为1G的**dataset(DAG)**。其中1G的数据集是通过16MB数据集生成而来的。

​	这样设计的目的为：对于方便轻节点进行验证，即再验证时只需要保存16M的Cache即可；对于矿工挖矿去设备专业化，为了更快的挖矿速度，需要对1G数组内容进行存储，从而增加了对内存访问。

​	**Cache：**

​	16MB的Cache数据生成方式与莱特币中生成方式较为类似。通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希获得的。

​	**DAG**：

​	DAG数组中每个元素都是从小数组中按照伪随机顺序读取一些元素，方法同莱特币中相同。如第一次读取A位置数据，对当前哈希值更新迭代算出下一次读取位置B，再进行哈希值更新迭代计算出C位置元素。如此来回迭代读取256次，最终算出一个数作为DAG中第一个元素，如此类推，DAG中每个元素生成方式都依次类推。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211011114647350.png" alt="image-20211011114647350" style="zoom:50%;" />

​	*在ETH中Cache和DAG数组的大小并不固定，考虑到计算机内存不断增大，两个数组需要定期增大。

​	**设计目的**：

​	轻节点只保存小的cache，验证时进行计算即可。但对于挖矿来说，如果这样则大部分算力都花费在了通过Cache计算DAG上面，因此，其必须保存大的数组DAG以便于更快挖矿。

​	**ETH挖矿过程：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211011115516279.png" alt="image-20211011115516279" style="zoom:50%;" />	

​	根据区块block header和其中的Nonce值计算一个初始哈希，根据其映射到某个初始位置A，读取A位置的数及其相邻的后一个位置A’上的数,根据该两个数进行运算，算得下一个位置B，读取B和B’位置上的数，依次类推，迭代读取64次，共读取128个数。

​	最后，计算出一个哈希值与挖矿难度目标阈值比较，若不符合就重新更换Nonce，重复以上操作直到最终计算哈希值符合难度要求或当前区块已经被挖出。

**伪代码实现ETH挖矿算法**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211011120616896.png" alt="image-20211011120616896" style="zoom:50%;" />

**PoW（工作量证明） >> PoS（权益证明）**

​	以太坊实现ASIC Resistance除了挖矿算法设计之外，还存在另外一个原因，即其预期从**工作量证明(POW)转向权益证明(POS)**

​	**权益证明:**

​	按照所占权益投票进行共识达成，类似于股份制有限共识按照股份多少投票，权益证明不需要挖矿。而这对于ASIC矿机厂商来说，ASIC芯片研发周期很长，成本很高，如果以太坊转入权益证明，这些投入的研发费用将全部白费(ASIC矿机只能用于挖特定的加密货币)。

**Pre-Mining（预挖矿）**

​	以太坊中采用的预挖矿的机制。这里“预挖矿”并不挖矿，而是在开发以太坊时，给开发者预留了一部分货币。

​	和Pre-Mining对应，还有Pre-Sale，Pre-Sale指的是将预留的货币出售掉用于后续开发，类似于拉风投或众筹。目前，各类加密货币很多，存在一部分货币就在采用Pre-Sale来获取资金，如果此时买入，后续如果该货币取得成功，同样可以获得很大收益，但真正成功的货币只占少数，这就是其风险性。

**其他观点：**

​	有一部分人认为让普通计算机参与挖矿反而是不安全的，因为要攻击系统，需要购入大量只能进行特定货币挖矿的矿机通过算力进行强行51%攻击，而攻击成功后，必然导致该币种的价值跳水，攻击者投入的硬件成本将会全部打水漂。

​	而如果让通用计算机也参与挖矿，发动攻击成本便大幅度降低，目前的大型互联网公司，将其服务器聚集起来进行攻击即可，而攻击完成后这些服务器仍然可以转而运行日常业务。

##### 6.ETH_挖矿难度调整

**引言：**

​	比特币难度调整是每隔2016个区块调整难度，从而达到维持出块时间10min的目标。而以太坊则与之不同，每个区块都有可能会进行难度调整。

**ETH难度调整：**

​	**调整算法：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211012212020471.png" alt="image-20211012212020471" style="zoom:40%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211012212151614.png" alt="image-20211012212151614" style="zoom:40%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211012212311340.png" alt="image-20211012212311340" style="zoom:40%;" />

​	**难度炸弹：**	

​		以太坊在设计之初就计划要逐步从POW（工作量证明）转向POS（权益证明），而权益证明不需要挖矿。因此，以太坊在设计之初便添加了难度炸弹，迫使矿工转入POS。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211012212525299.png" alt="image-20211012212525299" style="zoom:40%;" />

​	在以太坊早期时，区块号较小，难度炸弹计算所得值较小，难度调整级别基本上通过难度调整中的自适应难度调整部分决定，而随着越来越多区块被挖出，难度炸弹的威力开始显露出来，这也就使得挖矿变得越来越难，从而迫使矿工愿意转入POS。

​	**难度炸弹 2.0**

​	在实际应用中，权益证明的方式仍然并不成熟，目前以太坊共识机制仍然是POW，依然需要矿工参与挖矿维护以太坊系统的稳定。即转入POS的时间节点被一再推迟，虽然挖矿变得越来越难，系统出块时间开始逐渐变长，但矿工仍然需要继续挖矿。

​	在上面难度炸弹的公式中，第二项中的fake block number，该数仅仅为对当前区块编号减去了三百万，也就是相当于将区块编号回退了三百万个。在实际中，在转入权益证明时间节点一再推迟后，以太坊系统采取了将区块编号回退三百万个区块的方法来降低挖矿难度，当然，为了保持公平，也将出块奖励从5个以太币减少到了3个以太币

##### 7.ETH_权益证明

**引言：**

​	矿工挖矿的过程中消耗了大量的电力资源，其目的是为了取得出块奖励，从而获得收益，然而系统给予出块奖励的目的是激励矿工参与区块链系统维护，进行记账，而**挖矿本质上是看矿工投入资金来决定的(投入资金买设备->设备决定算力->算力比例决定收益)**。

​	那可以直接拼矿工之间的资金，现状是用资金购买矿机维护系统稳定，**那为什么不大家都将钱投入到系统开发和维护中，而根据投入钱的多少来进行收益分配呢**？这就是**权益证明**的基本思想。

**权益证明:**

​	一般来说，采用权益证明的货币，会先预留一些货币给开发者，而开发者也会出售一些货币换取开发所需要的资金，在系统进入稳定状态后，每个人都安装持有货币的数量进行投票。

​	**优点：**

​	1.省去了挖矿的过程，也避免了因此产生的能耗和对环境影响，减少了温室气体的排放。

​	2.维护区块链安全的资源形成闭环，而POW中维护其安全的资源需要通过现实中流通的货币购买矿机等设备进去区块链的，这也就导致只要有人想要攻击，只需要外部聚集足够资金就可以攻击成功(小型币种很容易被攻击，也就是在摇篮里就扼杀掉)。可见，POS机制可以有效防御这种情况。

​	**存在的缺陷：**

​		**双边下注：**

​		区块链系统产生了分叉，存在两个区块A和B竞争主链时，采用权益证明的方法就是所有持币者对这两个区块投入币进行投票，从而决定哪一个区块成为最长合法链上的区块。假如有一个人，在A和B同时进行了下注。最终A区块胜出，那么他能够获得A区块相应收益，而在B区块进行投票放入的“筹码”也会被退还，这也就导致其每次都能获得收益。

​		由于一个人可以拥有多个账户，所以我们无法强迫一个人一次只能投向一个区块。而越有钱的人，通过“双边下注”得到的收益也就越多。

**ETH采用的权益证明**		

**Casper the Friendly Finality Gadget（FFG）**

​	Casper协议引入一个概念：Validator(验证者)，一个用户想要成为Validator，需要上交一笔“保证金”，这笔保证金会被系统锁定。Validator的职责是推动系统达成共识，投票决定哪一条链成为最长合法链，投票权重取决于保证金数目。

​	实际中，采用两次投票的方式：预投票和Commit 投票，规定每次投票结果都要获得2/3以上的验证者同意。在实际中，针对其进行了一些修改，两次投票在实际中只需要一次即可。

​	矿工挖矿会获得出块奖励，而验证者也会得到相应奖励。当然，为了防止验证者的不良行为，规定其被发现时要受到处罚。例如某个验证者“行政不作为”，不参与投票导致系统迟迟无法达成共识，这时扣掉部门保证金；如果某个验证者“乱作为”，给两边都进行投票，被发现后没收全部保证金。没收的保证金被销毁，从而减少系统中货币总量。验证者存在“任期”，在任期结束后，进入“等待期”，在此期间等待其他节点检举揭发是否存在不良行为，若通过等待期，则可以取回保证金并获得一定投票奖励。

​	在该协议下，矿工无论算力多么强，最终投票权都不在其手中。必须在系统中，存在大量“验证者”进行了两边投票，也就是说，至少1/3（该协议规定超过2/3才有效）的验证者两侧都投票，才会导致系统被篡改。而这一旦被发现，这1/3验证者的保证金将会被没收。

​	以太坊系统设想，随着世界推移，挖矿奖励逐渐减少而权益证明奖励逐渐增多，从而实现POW到POS的过渡，最终实现完全放弃挖矿。

##### 8.ETH_智能合约

**智能合约：**运行在区块链上系统上的一段代码，代码逻辑定义了合约中的内容

​	含有智能合约的账户保存了合约当前的运行状态：

​		balance：当前余额

​		nonce：交易次数

​		code：合约代码

​		storage：存储，数据结构为MPT

**智能合约代码：**利用solidity语言，类似于JS，下图为公开拍卖的智能合约代码结构

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211019213550408.png" alt="image-20211019213550408" style="zoom:50%;" />

**账户调用：**

​	**1.外部普通账户调用合约账户：**

​		创建一个交易，接受地址为要调用的那个智能合约的地址，data域填写要调用的函数以及其参数的编码值。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211019213940753.png" alt="image-20211019213940753" style="zoom:50%;" />

​	**2.合约账户调用合约账户：**合约账户之间也可以进行相互调用

​		**a.直接调用：**

​			<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211019214233128.png" alt="image-20211019214233128" style="zoom:40%;" />

​		如果在执行a.foo()过程中抛出错误，则callAFooDirectly也抛出错误，本次调用全部回滚；可以通过.gas()和.value()调整提供gas数量或提供一些ETH。

​		**错误处理：**直接调用的方式，一方产生异常会导致另一方也进行回滚操作。

​	**b.address调用：**	

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211019214530499.png" alt="image-20211019214530499" style="zoom:40%;" />

​		**错误处理：**address.call()的方法，如果调用过程中被调用合约产生异常，会导致call()返回false，但发起调用的函数不会抛出异常，而是继续执行。

​	**c.代理调用：**和call()调用基本一致，区别在于其并不会切入被调用合约的上下文中。

**关于Payable：**		

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211019215009460.png" alt="image-20211019215009460" style="zoom:40%;" />

​	成员函数中的第一个函数，有一个payable修饰。原因是以太坊中规定，如果一个函数可以接收外部转账，则必须标记为payable。该例中背景为拍卖，bid()为出价，因此需要payable进行标记；withdraw()为其他未拍卖到的人将锁定在智能合约中的钱取出的函数，其不涉及转账，因此不需要payable进行标记。

**fallback函数**

```solidity
function() public [payable]{
	...
}
```

- 匿名函数，没有参数也没有返回值
- 在两种情况下会被调用
  - 直接向一个合约地址转账而不加任何data
  - 被调用的函数不存在

- 如果转账的金额不是0，同样需要声明payable，否则会抛出异常

​    **说明：**

​	该函数主要是防止A向B转账，但没有在data域中说明要调用哪个函数或说明的要调用函数不存在，此时调用fallback()函数。
​	只有合约账户才有代码，因此这些只和合约账户有关。如果没有fallback()，在发生之前的情况后，就会直接抛出异常。
​	另：转账金额和汽油费是不同的。汽油费是为了让矿工打包该交易，而转账金额是单纯为了转账，其可以为0，但汽油费必须给。

**智能合约创建与运行：**

​	**创建合约：**外部账户发起一个转账交易到0x0的地址，转账金额为0，但是需要支付汽油费，合约的代码放在data域里

​	智能合约运行在EVM上，EVM设计思想类似于JAVA中的JVM，便于跨平台增强可移植性。EVM中寻址空间256位。

​	以太坊是一个交易驱动的状态机，调用智能合约的交易发布到区块链后，每个矿工都会执行这个交易，从当前状态确定性地转移到下一个状态

**Gas Fee（汽油费）**

​	以太坊中功能很充足，提供图灵完备的平台，从而使得以太坊相对于比特币可以实现很多功能，但这也导致一些问题，例如当一个全节点收到一个对智能合约调用怎么知道其是否会导致死循环。

​	事实上，无法预知其是否会导致死循环，实际上，该问题是一个停机问题，而停机问题不可解。因此，以太坊引入汽油费机制将该问题扔给了发起交易的账户。
​	以太坊规定，执行合约中指令需要收取汽油费，并且由发起交易的人进行支付。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211019221344782.png" alt="image-20211019221344782" style="zoom:40%;" />

​	当一个全节点收到一个对智能合约的调用，先按照最大汽油费收取，从其账户一次性扣除，再根据实际执行情况，若汽油费不足以完成智能合约的执行，则会中断执行，回滚到执行前的状态，所消耗的汽油费不予退还。

​	而以太坊中，每个矿工都可以以前一个区块中gaslimt为基数，进行上调或下调1/1024，从而，通过绝大多数区块不断上下调整，保证得到一个较为理想化的gaslimt值。最终整个系统的gaslimt就是所有矿工希望的平均值。

​	**为什么要引入汽油费？**

​	以太坊中引入了智能合约，而智能合约逻辑很复杂，其字节数与消耗资源数并无关联。存在某些交易，从字节数来看很小，但其实际消耗资源很大(例如调用其他合约等)，因此要根据交易的具体操作收费，所有引入了汽油费这一概念。

​	在block header中包含了gaslimit，其并非将所有交易的消耗汽油费相加，而是该区块中所有交易能够消耗的资源的上限。

**错误处理：**

​	以太坊中交易具有原子性，要么全执行，要么全不执行，不会只执行一部分(包含智能合约)。在执行过程中产生错误导致回滚，已经消耗掉的汽油费是不会退回的。从而有效防止了恶意节点对全节点进行恶意调用。

​	智能合约中不存在自定义的try-catch结构，一旦遇到异常，除特殊情况外，本次执行操作全部回滚，可以抛出错误的语句：

- assert(bool condition):如果条件不满足就抛出，用于内部错误
- require(bool condition): 如果条件不满足就抛掉，用于输入或者外部组件引起的错误
- revert():终止运行并回滚状态变动。

​	**嵌套调用：**

​	嵌套调用是否发生回滚，取决于调用方式；一个合约向一个合约账户直接转账，因为fallback函数的存在，仍有可能会引发嵌套调用。

**挖矿与智能合约执行**

**问题：**假设全节点要打包一些交易到区块中，其中存在某些交易是对智能合约的调用。全节点应该先执行智能合约再挖矿，还是先挖矿获得记账权后执行智能合约？

 	实际上是**先执行智能合约后挖矿**，需要通过智能合约的执行改变三个树的哈希值，后通过blockHeader中的其他字段进行对nonce值的求解，从而进行挖矿。

**问题：**汽油费是怎样扣除的？

​	以太坊的数据结构中存在状态树、交易树、收据树。这三棵树都位于全节点中，是全节点在**本地**维护的数据结构，记录了每个账户的状态等数据，所以该节点收到调用时，是在本地对该账户的余额减掉即可。所以多个全节点每人扣一次，仅仅是每个全节点各自在本地扣一次。
即智能合约在执行过程中，修改的都是本地的数据结构，只有在该智能合约被发布到区块链上，所有节点才需要同步状态，各自在本地执行该智能合约。

**问题：**发布到区块链上的交易都是成功执行的吗？

​	为了防止恶意节点故意发布大量非法交易影响系统运行，对于其发布的交易即使无法成功执行也需要收取汽油费。但如果交易不被发布到区块链上，是无法收取汽油费的。

**问题：**智能合约支持多线程吗？

​	不支持，以太坊本质为一个交易驱动的状态机，面对同一组输入，必须转移到一个确定的状态。但对于多线程来说，同一组输入的输入顺序不同，最终的结果可能不一致。

















